#!/bin/sh -e

# Copyright (C) 2026 randoragon
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# For options and usage examples run "mkar -h" or "mkar --help"
# DEPENDENCIES:
# - GNU tar
# - gzip
# - bzip2
# - xz
# - zip
# - rar
# - 7z



# Error codes
ERR_BADARG=1
ERR_EXISTINGFILE=2
ERR_MERGEDUPE=3
ERR_BADPATH=4
ERR_ORPHANPATH=5
ERR_EXECUTION=6

# stderr wrappers
eecho () {
    if [ "$noerr" -ne 1 ]; then
        printf "mkar: %s\nTry 'mkar --help' for more information.\n" "$1" >&2
    fi
}
wecho () {
    if [ "$nowarn" -ne 1 ]; then
        printf "mkar: %s\n" "$1" >&2
    fi
}

# Checks if every argument is a file/directory/symlink
exists () {
    for y in "$@"; do
        if [ ! -f "$y" ] && [ ! -d "$y" ] && [ ! -L "$y" ]; then
            return 1
        fi
    done
    return 0
}

# Ranks a path by the number of parent dirs
dirrank () {
    realpath -s -- "$1" | tr -cd '/' | wc -m
}

# Finds the nth parent dir of a path (1st is always root)
ndirname () {
    if [ "$2" -eq 1 ]; then
        printf '/'
        return
    fi
    p="$(realpath -s -- "$1")"
    max="$(dirrank "$p")"
    for i in $(seq "$((max - $2 + 1))"); do
        p="$(dirname -- "$p")"
    done
    printf '%s' "$p/"
}

# Does the same thing as ndirname, but 1 is basename, 2 is basename of basename, etc.
nbasename () {
    p="$(basename -- "$1")"
    b="$(dirname -- "$1")"
    for i in $(seq "$(($2 - 1))"); do
        p="$(basename -- "$b")/$p"
        b="$(dirname -- "$b")"
    done
    printf '%s' "$p"
}

# Help page
usage () {
echo \
"MKAR - MaKe ARchive

NAME
        mkar - a simple tar/zip/rar/7z wrapper for creating archives

SYNOPSIS
    mkar OPTIONS PATH... [NAME]

DESCRIPTION
    Creates an archive \"NAME.EXT\" with all PATHs stored within. EXT is
    dependant on the used (if used) compression program, which can be defined
    using similar options as GNU tar, or omitted for a plain \"NAME.tar\" file.

    Symlinks are automatically dereferenced. Orphaned symlinks are skipped with
    a warning issued to stderr.

    An additional feature is subdirectory trimming. Most archiving utilities
    doesn't handle absolute paths well and unnecessarily recreate the entire
    subdirectory structure. For example, running:

        tar -chzf archive.tar.gz /home/user/file

    ...creates an archive with two subdirectories: home and user mkar cleverly
    cuts off as much of the path from the left as possible, so that running:

        mkar -z /home/user/file archive

    ...is a wrapper for:

        tar -chzf archive.tar.gz -C /home/user file

    When given multiple PATHs, the script will figure out the \"lowest common
    subdirectory\" and make that the root of the newly created archive.

    NAME can be omitted if only one PATH is supplied. When that happens, NAME is
    assumed to be \"PATH.EXT\".

OPTIONS
    -f, --force
        If NAME collides with an existing file, overwrite it.
        By default the operation will be aborted.

    -m, --merge
        By default, if PATHs reference files/dirs from different subdirectories,
        the subdirectory structure is preserved inside the new archive.
        This option prevents that by dropping all of the files/dirs in one
        common directory prior to compression. Aborts in case of name
        collisions. You can pass this parameter twice to skip colliding files
        instead of aborting the entire operation. PATHs passed earlier take
        priority over the latter ones.

    -i, --input
        Reads newline-delimited paths from stdin.

    -v, --verbose
        Enables verbose output from the compression program. This usually
        results in paths getting printed during the creation of an archive. If
        using tar (gzip, bzip2, xz or no compression), you can pass this option
        multiple times for extra levels of verbosity (see tar's man page on -v).

    -p, --pretend
        Prints the command(s) that would be run and exits. Note that if using
        the -m option, a temporary location will be created to dump symlinks to
        all the PATHs in, and those alternate paths will be printed instead.

    -z, --gzip
        Compress to NAME.tar.gz

    -j, --bzip2
        Compress to NAME.tar.bz

    -J, --xz
        Compress to NAME.tar.xz

    -Z, --zip
        Compress to NAME.zip

    -r, --rar
        Compress to NAME.rar

    -7, --7z
        Compress to NAME.7z

    -q, --quiet
        Pass it once to suppress just warnings, or twice to suppress all
        messages. Note that this only affects direct output from mkar, any
        third-party programs will still print their respective warnings and
        errors. This option is NOT mutually exclusive with --verbose.

EXAMPLES
    Create a tar archive for system and user xinitrcs:

        mkar -m /etc/X11/xinit/xinitrc ~/.xinitrc xfiles

    Compress a single file to file.tar.gz:

        mkar -z file

    Backup documents directory structure to a zip file:

        mkar -Z ~/Documents docs_backup

    Archive all txts from home directory in a tar file:

        find ~ -maxdepth 1 -type f -name '*.txt' | mkar -i txts

EXIT CODES
    0 - finished successfully
    1 - failed to parse arguments
    2 - FILE exists and no --force option passed
    3 - duplicate filenames when merging and only one -m passed
    4 - invalid PATH (does not exist)
    5 - PATH is an orphaned symlink
    6 - execution error

AUTHOR
    Written by Randoragon.

BUGS
    Note that I wrote this script for myself without the intent
    of making it a public product, so I don't guarantee anything.
    Email:   <randoragongamedev@gmail.com>
    Discord: Randoragon#1958

COPYRIGHT
    Copyright Â© 2020 Randoragon, MIT License
"
}

# Handle options
autoname=0
overwrite=0
merge=0
mnoskip=0
stdin=0
pretend=0
verbose=
compress=t
ext=tar
nowarn=0
noerr=0
OPTS="$(getopt -n mkar -s sh -o qhfmivpzjJZr7 -l quiet,help,merge,input,verbose,force,pretend,gzip,bzip2,xz,zip,rar,7z -- "$@")"
if [ $? -eq 1 ]; then
    eecho 'failed to parse command-line arguments'
    exit $ERR_BADARG
fi
eval set -- "$OPTS"
while true; do
    case "$1" in
        -f|--force) overwrite=1 ; shift ;;
        -m|--merge) [ $merge -eq 1 ] && mnoskip=1 || merge=1 ; shift ;;
        -i|--input) stdin=1 ; shift ;;
        -v|--verbose) verbose="v$verbose" ; shift ;;
        -p|--pretend) pretend=1 ; shift ;;
        -z|--gzip) compress=z; ext=tar.gz; shift ;;
        -j|--bzip2) compress=j; ext=tar.bz; shift ;;
        -J|--xz) compress=J; ext=tar.xz; shift ;;
        -Z|--zip) compress=Z; ext=zip; shift ;;
        -r|--rar) compress=r; ext=rar; shift ;;
        -7|--7z) compress=7; ext=7z; shift ;;
        -h|--help) usage ; exit ;;
        -q|--quiet)
            if [ $nowarn -eq 1 ]; then
                noerr=1
            else
                nowarn=1
            fi
            exit
            ;;
        --) shift ; break ;;
        *) break ;;
    esac
done
if [ $# -eq 1 ] && [ $stdin -ne 1 ]; then
    autoname=1
fi

if [ $# -eq 0 ]; then
    eecho "not enough arguments"
    exit $ERR_BADARG
fi

# Handle reading from stdin
if [ $stdin -eq 1 ]; then
    if [ $# -gt 1 ]; then
        eecho 'too many arguments'
        exit $ERR_BADARG
    fi
    cmd="$0"
    opts="$verbose$compress"
    opts="$opts$([ $merge -eq 1 ] && printf m)"
    opts="$opts$([ $mnoskip -eq 1 ] && printf m)"
    opts="$opts$([ $overwrite -eq 1 ] && printf f)"
    opts="$opts$([ $pretend -eq 1 ] && printf p)"
    opts="$opts$([ $nowarn -eq 1 ] && printf q)"
    opts="$opts$([ $noerr -eq 1 ] && printf q)"
    opts="$([ -n "$opts" ] && printf -- '-')$opts"
    tmpf="$(mktemp --tmpdir mkar.XXXXX)"
    # shellcheck disable=SC2064
    trap "rm -f -- '$tmpf'" INT QUIT TERM EXIT
    cat >"$tmpf"
    echo >>"$tmpf"
    sed -i '/^$/d' "$tmpf"
    if [ -n "$1" ]; then
        outfile="$1"
    elif [ "$(wc -l <"$tmpf")" -eq 1 ]; then
        outfile="$(cat -- "$tmpf")"
        outfile="$(basename -- "${outfile%%.*}")"
    else
        eecho 'failed to determine output filename; either argument missing or too many lines in input file'
        exit $ERR_BADARG
    fi
    printf "\n%s\n" "$outfile" >>"$tmpf"
    eval xargs -a "$tmpf" -d '\n' -- "$cmd" "$opts" --
fi

# Validate and parse input paths
paths=
for x in "$@"; do
    if [ $autoname -ne 1 ] && [ $# -eq 1 ]; then
        # $x is the outfile; it will be dealt with after this loop
        break
    fi
    if ! exists "$x"; then
        eecho "invalid path: '$x'"
        exit $ERR_BADPATH
    fi
    if ! realpath -e -- "$x" >/dev/null 2>&1; then
        eecho "orphaned symlink: '$x'"
        exit $ERR_ORPHANPATH
    fi
    paths="$paths
$x"
    shift
done

# Validate and parse output path
if [ $# -eq 1 ]; then
    outfile="$PWD/$(basename -- "$x").$ext"
    if [ -f "$outfile" ]; then
        if [ "$overwrite" -ne 1 ]; then
            eecho "a file '$outfile' already exists; use -f to overwrite"
            exit $ERR_EXISTINGFILE
        else
            rm -f -- "$outfile"
        fi
    elif [ -e "$outfile" ]; then
        eecho "'$outfile' already exists and is not a file; aborting"
        exit $ERR_EXISTINGFILE
    fi
    shift
fi

# Branch by compression program
case "$compress" in
    t|z|j|J)
        # Handle merge option
        if [ $merge -eq 1 ]; then
            tmpd="$(mktemp -d --tmpdir mkar.XXXXX)"
            # shellcheck disable=SC2064
            trap "rm -rf -- '$tmpd'" INT QUIT TERM EXIT
            rootdir="$tmpd"
            trimmedpaths=
            echo "$paths" | while read -r x; do
                if ! realpath -e -- "$x" >/dev/null 2>&1; then
                    wecho "Warning: '$x' is an orphaned symlink (skipping)."
                    continue
                fi
                t="$(basename -- "$x")"
                d="$tmpd/$t"
                if exists "$d"; then
                    if [ $mnoskip -eq 1 ]; then
                        wecho "Warning: duplicate name '$t' (skipping)."
                        continue
                    fi
                    eecho "duplicate name '$t'"
                    exit $ERR_MERGEDUPE
                fi
                ln -s -- "$(realpath -- "$x")" "$d"
                trimmedpaths="$trimmedpaths
$t"
            done
        else
            # Find the lowest common parent dir
            check () {
                IFS="
"
                foo () { printf "%s" "$1"; }
                lastval="$(ndirname "$(foo $@)" $i)"
                for p in $@; do
                    [ "$(ndirname "$p" $i)" != "$lastval" ] && unset IFS && return 1
                    lastval="$(ndirname "$p" $i)"
                done
                printf "1"
                unset IFS
            }
            i="$(dirrank "$1")"
            while [ -z "$(check "$paths")" ]; do
                i=$((i - 1))
            done
            rootdirindex="$i"

            # Trim all the paths to leave out only the right portion not included in $rootdir
            trimmedpaths=
            trim () {
                IFS="
"
                foo () { printf "%s" "$1"; }
                rootdir="$(ndirname "$(foo $@)" "$rootdirindex")"
                for p in $@; do
                    q="$(realpath -s -- "$p")"
                    trimmedpaths="$trimmedpaths
$(nbasename "$q" "$(($(dirrank "$q") - rootdirindex + 1))")"
                done
                unset IFS
            }
            trim "$paths"
        fi

        # Create the archive
        createtar () {
            IFS="
"
            [ $compress = t ] && compress=
            opts="-ch$compress$verbose"f
            if [ $pretend -eq 1 ]; then
                printf "%s" "tar $opts '$outfile' -C '$rootdir' "
                foo () { for line in $@; do printf "%s" "'$line' "; done; }
                foo "$trimmedpaths"
                printf '\n'
            else
                tar "$opts" "$outfile" -C "$rootdir" $@
            fi
            unset IFS
        }
        createtar "$trimmedpaths"

        # Delete temporary data
        [ -d "$tmpd" ] && rm -rf "$tmpd"
    ;;
    Z|r|7)
        # Handle merge option
        if [ $merge -eq 1 ]; then
            tmpd="$(mktemp -d --tmpdir mkar.XXXXX)"
            # shellcheck disable=SC2064
            trap "rm -rf -- '$tmpd'" INT QUIT TERM EXIT
            rootdir="$tmpd"
            move () {
                IFS="
"
                trimmedpaths=
                for x in $@; do
                    [ -z "$(readlink -e -- "$x")" ] && wecho "Warning: '$x' is an orphaned symlink (skipping)." && continue
                    t="$(basename -- "$x")"
                    d="$tmpd/$t"
                    exists "$d" && {
                        [ $mnoskip -eq 1 ] && wecho "Warning: duplicate name '$t' (skipping)." && continue
                        eecho "duplicate name '$t'" && exit $ERR_MERGEDUPE
                    }
                    ln -s "$(realpath -- "$x")" "$d"
                    trimmedpaths="$trimmedpaths
$t"
                done
                unset IFS
            }
            move "$paths"
        else
            # tar supports the -C parameter when creating archives, which basically allows us to set
            # the "root directory" of an archive to anything we want, which is useful. The programs
            # for zipping, raring and 7zipping do not have that option, so instead we have to cd
            # into the "root directory" of the soon-to-be archive, create it from the root with
            # relative paths, and cd back to where we came from.

            # Find the lowest common parent dir (rootdir)
            check () {
                IFS="
"
                foo () { printf "%s" "$1"; }
                lastval="$(ndirname "$(foo $@)" $i)"
                for p in $@; do
                    [ "$(ndirname "$p" $i)" != "$lastval" ] && unset IFS && return 1
                    lastval="$(ndirname "$p" $i)"
                done
                printf "1"
                unset IFS
            }
            i="$(dirrank "$1")"
            while [ -z "$(check "$paths")" ]; do
                i=$((i - 1))
            done
            rootdirindex="$i"

            # Trim all the paths to leave out only the right portion not included in $rootdir
            trimmedpaths=
            trim () {
                IFS="
"
                foo () { printf "%s" "$1"; }
                rootdir="$(ndirname "$(foo $@)" $rootdirindex)"
                for p in $@; do
                    q="$(realpath -s -- "$p")"
                    trimmedpaths="$trimmedpaths
$(nbasename "$q" $(($(dirrank "$q") - rootdirindex + 1)))"
                done
                unset IFS
            }
            trim "$paths"
        fi

        # Create the archive
        create () {
            IFS="
"
            if [ $pretend -eq 1 ]; then
                printf "%s\n" "cd '$rootdir'"
                case $compress in
                    Z) printf "%s" "zip -$([ -z "$verbose" ] && printf q)r '$outfile' "
                        ;;
                    r) printf "%s" "rar $([ -z "$verbose" ] && printf "%s" '-idq') a '$outfile' "
                        ;;
                    7) printf "%s" "7z a -l -y -t7z '$outfile' "
                        ;;
                esac
                foo () { for line in $@; do printf "%s" "'$line' "; done; }
                foo "$trimmedpaths"
                [ "$compress" = 7 ] && [ -z "$verbose" ] && printf -- '>&-'
                printf "\n%s\n" "cd '$PWD'"
            else
                prevpwd="$PWD"
                cd -- "$rootdir" || exit "$ERR_EXECUTION"
                case $compress in
                    Z) zip -"$([ -z "$verbose" ] && printf q)"r "$outfile" $@
                        ;;
                    r) rar "$([ -z "$verbose" ] && printf "%s" '-idq')" a "$outfile" $@
                        ;;
                    7) if [ -z $verbose ]; then 7z a -l -y -t7z "$outfile" $@ >&-; else 7z a -l -y -t7z "$outfile" $@; fi
                        ;;
                esac
                cd -- "$prevpwd" || exit "$ERR_EXECUTION"
            fi
            unset IFS
        }
        create "$trimmedpaths"

        # Delete temporary data
        [ -d "$tmpd" ] && rm -rf "$tmpd"
    ;;
esac
